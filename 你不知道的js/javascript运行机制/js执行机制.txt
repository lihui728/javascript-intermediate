一：浏览器常驻的线程

  1:JS引擎线程（解释执行js代码，用户输入，网络请求）
  
  2：GUI线程(绘制用户界面，与js主线程是互斥的)
  
  3：http网络请求线程（处理用户的get,post等请求，等返回结果后将回调函数推入任务队列）
  
  4：定时触发器线程(setTimeout,setInterval等待时间借宿后把执行函数推入任务队列中)
 
  5：浏览器事件处理线程(将click，mouse等交互事件发生后将这些事件放入事件队列中)

  http网络请求，比如在前端发送网络请求，ajax发送一个异步请求，请求之后，服务器把数据

  返回给用户之后，是要触发回调函数的，那个时候，是由http网络请求线程，由它来执行回调管控
 
  大部分浏览器都是有这五个线程的。这五个线程UI主线程通过它协调，运作。

  
二:UI主线程负责协调运转

  javascript引擎线程 

  javascript引擎线程的里面每一个都是可以当做任务，任务的本身可以看成函数执行，
  
  无论是触发管控事件的线程，它会把任务推入javascript引擎之中，定时器隔了一段时间，
 
  把它推入javascript引擎之中，网络请求之后，数据要往回传，回调函数被触发，也是当做
  
  一个任务，这几种任务最后会被推入到javascript引擎之中。
  
  GUI线程

  只要页面发生了一些显示标签，css样式，用户能看的见这些变化，都是由GUI的线程完成。

三:js引擎线程和GUI线程-互斥
 
  js可以操作DOM元素，进而会影响到GUI的渲染结果，因此JS引擎线程与GUI渲染线程是互斥的，
 
  也就是说当JS引擎线程处于运行状态时，GUI渲染线程将处于冻结状态
  
  列：<script>
        
       var oBtn = document.getElementByid('btn');
       dieLoop();
       oBth.onclick = function (){
       //dieloop
   }
   function dieLoop(){
    while(true){
     console.log('0');
    }  
  } 
  
    </script>
  当dieLoop()执行了，因为这是个死循环，js引擎会不断执行dieLoop这一块的代码中，

  后面无论在有什么任务，怎样操作，触发，都不会执行，说明JavaScript引擎线程是一个单线程
 
  ，所带来的一种状况
  
  当点击bttom的时候，会发生以下动作
  
  把事件对应的处理函数，当做一个任务，把它推入到javascript引擎中，等待它去执行。
  
  除此之外，还有浏览器GUI渲染线程，去进行按钮变化样式处理，那是由谁把它放到
 
 javascript引擎线程之中呢？是浏览器事件处理线程来监听这个任务，并且把这个任务推入到
 
 javascript引擎线程之中。

四：js执行机制-多线程不好吗？

    js设计出来就是为了与用户交互，处理DOM，假如js是多线程，同一时间一个线程想要修改DOM，

    另一个线程想要删除DOM，问题就变得复杂许多，浏览器不知道听谁的，如果引入“锁”的机制，
   
    这不就又回到了被其他语言尴尬的困境了吗。

    列：大量数据进行渲染的时候，或者后端给了大量的数据，需要生成大量的标签，这样的话，是
      
        单线程的话，计算能力不是很强，那依旧到达不了很好的效果，比如说十万个li进行渲染，
   
        频繁的删除，修改，单线只能同时干一个活，这么多数据，渲染起来花很长时间

五：大量数据操作怎么办？
 
    单线程计算能力有限，大量数据需要计算渲染的话，我们可以配合后端进行操作，可以用VUE
   
    与node.js配合，也就是传说中的SSR技术
    
    SSR技术：是叫服务端渲染技术，可以通过这种技术，在后台进行大量数据的计算，计算之后生成标签
 
   或者说生成字符串形式的组件，在返回到前端之中，然后在前端把这个组件生成到页面来。这样的情况
  
   VUE和node.js相互配合，就可以完成大量数据的计算。

六：js执行机制
  
    javascript是基于单线程运行的，同时又是可以异步执行的，一般来说这种既是单线程又是异步的语言
  
    都是基于事件来驱动的，恰好浏览器就给javascript提供了这么一个环境

    那这个环境除了js引擎线程机制以外，其实还有其他线程进行配合，最后表现状态就是js引擎线程的
 
    主线程，是单线程的，它确实是一个时间段只能干一件事情，但是是可以异步的进行操作的话，是由于
 
    其他线程的介入，辅助。最后才呈现出来js在浏览器运行的时候又可以同步，又可以异步

    js执行机制图

    把每一个要执行的函数或者说执行代码当做一个任务，首先任务是一个普通函数的执行，不涉及到
  
    异步的操作，就不如说不涉及到事件触发，定时器，网络请求，那么这个普通的任务就是一个同步
  
    任务。同步任务放到主线程之中。主线程里面有个执行栈，主线程是单线程的，任务多点话,那么就

    得一个个执行。第一个任务还没执行完，那么其他任务也执行不了。如果主线里面有很多任务，那么
  
    这些任务一个个都执行完了之后，那么接下来它会看一下读取任务队列中的结果，那什么是任务队列？
   
    如果说一开始任务不是同步任务，是个异步任务，那么异步任务首先会进入到Event Table之中，先
  
    注册一下，有这样的一个函数，之后在某一个时间段被触发，在这注册完之后，等到。。。。。
 
    比如说定时器延迟时间到了，这个函数，或说任务真正去被执行了。或者说发送了网络请求的时候，

    那这个数据真正返回到前端，那也就是真正要执行回调函数，这时候就会把这个函数或者说任务，

    放入到页面的Evnet Queue，放到这个事件任务队列里面，现实的队列：先进先出，栈不一样
 
    栈概念：先进后出。主线程的任务全部执行完了之后，会去看一下事件/任务队列中时候还有其他

    任务，如果有的话，就会拿出来执行。那这个过程中，当主线程的任务全部执行完之后，会不断
  
    反复看任务队列有没有任务。这个过程叫做事件循环。

    
    导图要表达的内容用文字来表述的话
   
    同步和异步任务分别进入不同的执行“场所”，同步的进入主线程，异步到进入Event Table并注册函数。
  
    当指定的事情完成时，Event Table会将这个函数移入Event Queue.
    （当指定的事情完成时：就是定时器延迟多少毫秒，出触发这样的函数。当向服务器发现数据请求以后，
     当数据回来了触发这个回调函数。当dom事件，被用户触发的时候，它也会把Event Table中，所注册的
     函数，放到任务队列里面来。当主线程执行完毕之后，回来重复以下动作：看一下事件任务队列，
     有没有任务，如果有一个个按顺序的拿出来执行，这样的重复的事情，就是Event Loop。（事件循环）
   ）
  
    主线程内的任务执行完毕为空，回去Event Queue读取对应的函数，进入主线执行。
  
    上述的过程会不断重复，也就是常说的Event Loop(事件循环)；

    
七：同步任务(除了ajax，异步网络请求，定时器，事件的触发除此这样，都是同步任务)
    函数执行就是同步任务
     function foo(ot){
       function bar(it){
          console.log(it);
   }
        bar(20);
        console.log(ot);
  }
  foo(10);
   
  执行栈

  定义一个函数，并没有把它当做一个任务，执行的时候才能被当做一个任务。

  同步任务和异步任务都会放到执行栈中。去执行
  
  同步任务
  
  每个函数执行或者说任务,都是会放到执行栈之中的，当没有代码,函数执行的时候，执行栈是空的。
  
  1:foo函数执行时，创建了一帧，这帧中包含了形参，局部变量(预编译)，然后把这一帧压入栈中
    栈的存储概念：先进后去，比如说foo函数执行，先被放进栈之中。然后在执行foo内部的代码时候，
    再执行bar这个函数。也是说在foo执行的时候，还没执行完，就执行了bar;那么bar也会进行预编译过程，
    创建新的一帧，创建完之后也会把这一帧被压入到栈之中。当bar的函数执行完之后，就会弹出栈。从
    栈中出去，没有了，那么只剩下foo。或者说这个任务执行完了之后，真正被执行的是foo了。foo函数执行
    完毕，弹出栈，执行栈为空。最后回去看一下事件任务队列有没有的新的任务，有任务的话，再放到执行栈
    之中执行。一般情况下，我们把执行栈当做js主线程，执行栈只能在同一个时间段里面干一件事情。
  
八:异步任务
   
    $.ajax({
      url:'localhost:/js/demo.json',
      date: {},
      success:function(date){
         console.log(date);
   } 
 })
  console.log('run');

 代码的理解：
 
 向这个地址发送这个请求，穿进去的参数什么都没有，当数据请求回来以后，返回到前端以后，会触发回调
 函数，会在回调函数里面执行，返回来的数据

 流程过程
  
 首先ajax发送请求，这是一个异步的任务，会走右边的流程去走，Ajax进入Event Table,注册回调函数success,
 这个函数success已经被注册好了。那什么时候触发了，只有当ajax事件完成以后，http网络请求线程把
 任务或者把sucees函数执行任务，放到事件队列以后，那么主线程都执行完之后，才会触发它。
 
 当执行这一段代码的时候，当异步的任务发送以后，请求会有一定等待的事件，那当它看完这一段话之后，
 请求那个时间段就到了下面的一段话console.log('run');这句话也是一个任务，去输出一个run，那最后的状态
 是先输出run，等输出了run之后，才会去 当这个数据请求回以后 被放到这个任务队列以后，console.log的
 任务也执行完了，这个执行栈为空了，才会去看任务队列有没有任务，如果有再拿到执行栈里面执行。

九：js执行机制--单线程
    
    js的主线程是一个单线程，在js执行的时候，会创建heap,stack(堆栈)，就是执行栈，每个函数执行，
    或者每个功能的代码执行，待会被当做任务放到这个栈之中，按照先进先去一个个执行，在执行过程中
    他把他，把前面一段话拿出来执行，执行完以后，会把下一个任务拿出来执行。如果下一个任务是ajax，
    那么js引擎线程就会调用WebAPIs,WebAPIs是js引擎线程外部所提供的一些功能，只需跟它借用一下，使用一下
    那么发送一个网络请求，把WebAPIs的功能拿到js引擎线程之中，去做一个网络请求的操作，这个功能是
    外部提供的，只需把它借过来，使用。在使用的时候，请求发出去。到了服务器端了。那剩下的事情谁来
    管控，由http网络请求线程，由它来管控。数据回来的时候，会监测到，会把这个回调函数放到事件队列
    Event Queue来，放到里面之后，它会进行一个排队。比如说，之前还触发一个事件处理函数，也会当成
    任务，放到事件队列Event Queue来，也有个定时器，隔了一段时间触发，也放到了Event Queue来，ajax
    是最后把这个数据请求回来。所以会放到他们两个任务之后才会触发，按顺序进行排队，在排队的时候
    并不是一排队就能触发，而是这个js主线程的执行栈的任务执行完，为空的时候，才会去看任务队列有没有
    任务，有的话，就拿出来执行，执行完之后看一下，有，执行。重复这动作(事件循环event loop),
    如果有个任务是死循环的话，那么它一直执行，没执行，是不会去看任务队列的，这就是js主单线程。
    GUI，http。定时触发线程，事件都是辅助js引擎线程。来完成看似是异步的操作，但最终js引擎线程
    还是单线程的。
    
十：重新理解定时器
    
    setTimeout的等待时间结束后并不是直接执行的而是先推入浏览器的一个任务队列，在同步队列结束后再
    依次调用任务队列中的任务。
    
     setTimeout(function (){},0)js主线程中的执行栈为空时，o毫秒实际上也达不到的，根据HTML标准，
     最低4毫秒
    
     setInterval是每隔一段时间把任务放到Evnet Queue之中。

33:00

















